on:
  pull_request: {}
  push:
    branches:
    - main
    - master
    paths:
    - .github/workflows/semgrep.yml
  schedule:
  # random HH:MM to avoid a load spike on GitHub Actions at 00:00
  - cron: 6 14 * * *
name: Semgrep
permissions:
  contents: read
concurrency:
  # Keep one Semgrep run per ref; cancel stale runs to reduce queue pressure.
  group: semgrep-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true
jobs:
  semgrep:
    name: Scan
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}
    container:
      image: returntocorp/semgrep:latest@sha256:b6a1bae371d313a8bddf0418b3e094e7cda4f1d77afeeecaa6b08c7f400349ff
    steps:
    - uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # ratchet:actions/checkout@v4
      with:
        persist-credentials: false
    - name: Run Semgrep scan
      shell: sh
      run: |
        set -eu

        # Bound runtime to avoid stuck scans keeping this check in-progress.
        if command -v timeout >/dev/null 2>&1; then
          set +e
          timeout --signal=SIGTERM --kill-after=60s 25m \
            semgrep ci --disable-version-check --metrics=off --interfile-timeout=1200
          status=$?
          set -e
          if [ "${status}" -eq 124 ] || [ "${status}" -eq 137 ]; then
            echo "::error::Semgrep exceeded 25 minutes and was terminated."
          fi
          exit "${status}"
        fi

        echo "::warning::'timeout' utility not found; relying on job timeout."
        semgrep ci --disable-version-check --metrics=off --interfile-timeout=1200
